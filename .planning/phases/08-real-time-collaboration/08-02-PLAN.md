---
phase: 08-real-time-collaboration
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - lib/hooks/use-realtime-investors.ts
  - lib/hooks/use-presence.ts
  - lib/hooks/use-optimistic-update.ts
autonomous: true

must_haves:
  truths:
    - "useRealtimeInvestors hook subscribes to postgres_changes and updates local investor state on INSERT/UPDATE/DELETE"
    - "usePresence hook tracks which users are viewing/editing which records via Supabase Presence API"
    - "useOptimisticUpdate hook performs version-checked updates and detects conflicts"
    - "All hooks clean up Supabase channels on component unmount to prevent memory leaks"
  artifacts:
    - path: "lib/hooks/use-realtime-investors.ts"
      provides: "Real-time investor list subscription"
      exports: ["useRealtimeInvestors"]
    - path: "lib/hooks/use-presence.ts"
      provides: "User presence tracking per record"
      exports: ["usePresence"]
    - path: "lib/hooks/use-optimistic-update.ts"
      provides: "Version-checked investor updates with conflict detection"
      exports: ["useOptimisticUpdate"]
  key_links:
    - from: "lib/hooks/use-realtime-investors.ts"
      to: "lib/supabase/client.ts"
      via: "createClient for WebSocket subscription"
      pattern: "createClient.*channel.*postgres_changes"
    - from: "lib/hooks/use-presence.ts"
      to: "lib/supabase/client.ts"
      via: "createClient for Presence channel"
      pattern: "createClient.*channel.*presence"
    - from: "lib/hooks/use-optimistic-update.ts"
      to: "types/investors.ts"
      via: "version field for conflict check"
      pattern: "eq.*version.*currentVersion"
---

<objective>
Create three React hooks for real-time collaboration: useRealtimeInvestors (live database subscriptions), usePresence (user presence tracking), and useOptimisticUpdate (version-based conflict detection).

Purpose: Encapsulate all real-time logic in reusable hooks that Plan 03 wires into existing UI components.
Output: Three hook files in lib/hooks/ following existing project patterns.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-real-time-collaboration/08-RESEARCH.md
@.planning/phases/08-real-time-collaboration/08-01-SUMMARY.md
@lib/supabase/client.ts
@lib/hooks/use-auth.ts
@types/investors.ts
@types/realtime.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useRealtimeInvestors hook for live database subscriptions</name>
  <files>lib/hooks/use-realtime-investors.ts</files>
  <action>
    Create a React hook that subscribes to Supabase Realtime postgres_changes on the investors table.

    **Hook signature:**
    ```typescript
    export function useRealtimeInvestors(initialInvestors: InvestorWithContacts[]): {
      investors: InvestorWithContacts[]
      connectionStatus: ConnectionStatus
    }
    ```

    **Implementation details:**
    - Accept `initialInvestors` from server-side fetch (Server Component passes as prop)
    - Initialize state with `useState(initialInvestors)`
    - Sync initialInvestors changes with `useEffect` (when parent re-fetches, e.g., after filter change) — update state if initialInvestors reference changes
    - Subscribe to `postgres_changes` on `public.investors` table for events: `*` (INSERT, UPDATE, DELETE)
    - On INSERT: prepend new investor to list (set contacts to empty array, primary_contact to null since subscription doesn't include joins)
    - On UPDATE: map over existing investors, replace matching id with payload.new, preserve contacts/primary_contact from existing record
    - On DELETE: filter out investor with matching id
    - Track connection status: 'connecting', 'connected', 'error', 'closed'
    - Handle subscription status callback: SUBSCRIBED, CHANNEL_ERROR, TIMED_OUT, CLOSED
    - Channel name: `'investors-realtime'`
    - Cleanup: `supabase.removeChannel(channel)` in useEffect return
    - Add 'use client' directive at top

    **Important patterns (from research):**
    - Store channel reference in useEffect scope, not component state
    - Handle soft deletes: UPDATE with deleted_at set should remove from list
    - Log connection status changes to console for debugging
    - Use the existing `createClient()` from `@/lib/supabase/client`
  </action>
  <verify>
    - File exists at lib/hooks/use-realtime-investors.ts
    - Exports useRealtimeInvestors function
    - Has 'use client' directive
    - Subscribes to postgres_changes with event '*' on investors table
    - Returns { investors, connectionStatus }
    - Cleanup function calls supabase.removeChannel
    - `npx tsc --noEmit --pretty 2>&1 | head -20`
  </verify>
  <done>useRealtimeInvestors hook subscribes to live investor changes and returns updated list with connection status</done>
</task>

<task type="auto">
  <name>Task 2: Create usePresence and useOptimisticUpdate hooks</name>
  <files>
    lib/hooks/use-presence.ts
    lib/hooks/use-optimistic-update.ts
  </files>
  <action>
    **lib/hooks/use-presence.ts:**
    Create a hook for tracking which users are viewing/editing investor records.

    ```typescript
    export function usePresence(recordId?: string): {
      onlineUsers: PresenceState[]
      updatePresence: (update: { viewing_record_id?: string | null; editing_field?: string | null }) => Promise<void>
    }
    ```

    Implementation:
    - Get current user from `useAuth()` hook (from `@/lib/hooks/use-auth`)
    - Create a single shared channel: `'crm-presence'` with config `{ presence: { key: user.id } }`
    - On 'presence' 'sync' event: get presenceState(), flatten values, update onlineUsers state
    - On SUBSCRIBED: track initial presence with user_id, username (from user.email split), viewing_record_id (from recordId prop), editing_field null, online_at timestamp
    - `updatePresence` function: calls channel.track() with updated fields
    - Filter onlineUsers to only those viewing the current recordId (if provided)
    - Cleanup: removeChannel on unmount
    - 'use client' directive

    **lib/hooks/use-optimistic-update.ts:**
    Create a hook for version-checked updates with conflict detection.

    ```typescript
    export function useOptimisticUpdate(): {
      updateInvestor: (investorId: string, currentVersion: number, field: string, value: unknown) => Promise<OptimisticUpdateResult<Investor>>
      isUpdating: boolean
    }
    ```

    Implementation:
    - Use the existing server action pattern: call `updateInvestorField` from `@/app/actions/investors`
    - BUT also pass version check via a new approach: since updateInvestorField doesn't support version yet, create a NEW server action `updateInvestorFieldWithVersion` in the same action call. Actually, SIMPLER: use the Supabase client directly from browser for the version check, then call the server action. NO — this creates a split-brain.
    - CORRECT approach: Use Supabase browser client directly for version-checked updates. The browser client respects RLS policies. Steps:
      1. `supabase.from('investors').update({ [field]: value, version: currentVersion + 1, updated_at: new Date().toISOString() }).eq('id', investorId).eq('version', currentVersion).select().single()`
      2. If no data returned (0 rows updated), it's a conflict
      3. Also log the activity via the existing createActivity server action or a separate activity insert
    - Actually, to keep it simple and avoid duplicating activity logging: Create a `updateInvestorFieldOptimistic` server action in Plan 03 that wraps the existing logic with version checking. For NOW in this hook, just provide the client-side interface that calls it.
    - SIMPLEST: The hook provides a wrapper that calls a server action (to be created in Plan 03's task). For now, create the hook skeleton that accepts a `performUpdate` callback, OR just implement it with direct Supabase client calls for the version check.

    FINAL DECISION: Use Supabase browser client for the version-checked update. This is clean because:
    - RLS already protects the update
    - Version check happens at database level (atomic)
    - No need for additional server action complexity
    - Activity logging for field_update is a nice-to-have that real-time events partially replace

    Implementation:
    - `createClient()` from `@/lib/supabase/client`
    - `updateInvestor(investorId, currentVersion, field, value)`:
      1. Set isUpdating true
      2. Execute update with `.eq('version', currentVersion)` check
      3. If error or no data: return `{ success: false, conflict: true }`
      4. If success: return `{ success: true, conflict: false, data }`
      5. Set isUpdating false
    - 'use client' directive
  </action>
  <verify>
    - lib/hooks/use-presence.ts exists, exports usePresence, has 'use client'
    - lib/hooks/use-optimistic-update.ts exists, exports useOptimisticUpdate, has 'use client'
    - usePresence subscribes to presence channel with sync event
    - useOptimisticUpdate uses .eq('version', currentVersion) pattern
    - Both hooks have cleanup functions for channel removal
    - `npx tsc --noEmit --pretty 2>&1 | head -20`
  </verify>
  <done>usePresence tracks online users with record-level granularity; useOptimisticUpdate performs version-checked updates with conflict detection</done>
</task>

</tasks>

<verification>
- All three hooks exist in lib/hooks/
- Each hook has 'use client' directive
- Each hook properly cleans up Supabase channels on unmount
- useRealtimeInvestors handles INSERT, UPDATE, DELETE events
- usePresence tracks viewing_record_id and editing_field
- useOptimisticUpdate checks version column for conflicts
- `npx tsc --noEmit` passes (or only pre-existing errors)
</verification>

<success_criteria>
Three reusable hooks encapsulate all real-time collaboration logic. Each hook is self-contained, follows existing project patterns (use-auth.ts, use-role.ts), and is ready for integration into UI components in Plan 03.
</success_criteria>

<output>
After completion, create `.planning/phases/08-real-time-collaboration/08-02-SUMMARY.md`
</output>
