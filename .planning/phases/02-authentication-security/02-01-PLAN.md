---
phase: 02-authentication-security
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/database/migrations/001_create_user_roles.sql
  - lib/database/migrations/002_create_auth_hook.sql
  - lib/database/migrations/003_enable_supa_audit.sql
  - lib/database/migrations/004_create_rls_policies.sql
  - lib/database/migrations/005_create_audit_triggers.sql
  - lib/database/migrations/006_seed_initial_users.sql
  - types/auth.ts
autonomous: true

must_haves:
  truths:
    - "user_roles table exists with app_role enum (admin, member)"
    - "Auth Hook function adds user_role claim to JWT tokens"
    - "supa_audit extension is enabled and tracking configured"
    - "app_audit_log table exists for application-level events"
    - "is_admin() helper function works for RLS policies"
    - "TypeScript types for roles and auth are defined"
  artifacts:
    - path: "lib/database/migrations/001_create_user_roles.sql"
      provides: "user_roles table with app_role enum"
      contains: "create type public.app_role"
    - path: "lib/database/migrations/002_create_auth_hook.sql"
      provides: "Auth Hook for JWT custom claims"
      contains: "custom_access_token_hook"
    - path: "lib/database/migrations/003_enable_supa_audit.sql"
      provides: "supa_audit extension activation"
      contains: "create extension"
    - path: "lib/database/migrations/005_create_audit_triggers.sql"
      provides: "app_audit_log table and triggers"
      contains: "app_audit_log"
    - path: "types/auth.ts"
      provides: "TypeScript types for AppRole, UserProfile"
      contains: "AppRole"
  key_links:
    - from: "002_create_auth_hook.sql"
      to: "001_create_user_roles.sql"
      via: "Hook reads from user_roles table"
      pattern: "from public.user_roles"
    - from: "004_create_rls_policies.sql"
      to: "002_create_auth_hook.sql"
      via: "RLS uses role claim from JWT"
      pattern: "auth.jwt.*user_role"
---

<objective>
Create the database foundation for authentication and authorization: user_roles table, Auth Hook for JWT custom claims, supa_audit extension, audit logging tables, RLS helper functions, and TypeScript type definitions.

Purpose: All auth features (RBAC, audit logging, route protection) depend on these database objects existing. This is the data layer foundation for the entire auth system.
Output: SQL migration files ready to execute in Supabase SQL Editor, plus TypeScript types for the auth system.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-authentication-security/02-RESEARCH.md
@.planning/phases/02-authentication-security/02-CONTEXT.md
@.planning/phases/01-foundation-environment/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SQL migration files for auth database schema</name>
  <files>
    lib/database/migrations/001_create_user_roles.sql
    lib/database/migrations/002_create_auth_hook.sql
    lib/database/migrations/003_enable_supa_audit.sql
    lib/database/migrations/004_create_rls_policies.sql
    lib/database/migrations/005_create_audit_triggers.sql
    lib/database/migrations/006_seed_initial_users.sql
  </files>
  <action>
    Create 6 SQL migration files in lib/database/migrations/. These are designed to be run sequentially in Supabase SQL Editor.

    **001_create_user_roles.sql:**
    - Create `app_role` enum type with values 'admin' and 'member'
    - Create `user_roles` table: id (bigint identity PK), user_id (uuid references auth.users ON DELETE CASCADE, NOT NULL), role (app_role NOT NULL), created_at (timestamptz default now()), updated_at (timestamptz default now()), UNIQUE(user_id, role)
    - Enable RLS on user_roles
    - Policy: "Admins can manage user roles" - for ALL to authenticated, using (exists (select 1 from public.user_roles ur where ur.user_id = auth.uid() and ur.role = 'admin'))
    - Policy: "Users can view all roles" - for SELECT to authenticated, using (true)
    - Add comment: "Run in Supabase SQL Editor - Migration 1 of 6"

    **002_create_auth_hook.sql:**
    - Create function `public.custom_access_token_hook(event jsonb)` returns jsonb, language plpgsql, marked STABLE
    - Function logic: fetch user_role from user_roles where user_id matches event->>'user_id', set claims.user_role to found role or default to 'member' if no role assigned
    - GRANT execute to supabase_auth_admin
    - REVOKE execute from authenticated, anon, public
    - Add comment explaining this must be configured in Supabase Dashboard: Authentication > Hooks > Custom Access Token Hook after running SQL

    **003_enable_supa_audit.sql:**
    - `create extension if not exists supa_audit cascade;`
    - Note: tracking will be enabled on specific tables as they are created (investors table in Phase 3). For now, enable tracking on user_roles: `select audit.enable_tracking('public.user_roles'::regclass);`

    **004_create_rls_policies.sql:**
    - Create helper function `public.is_admin()` returns boolean, language plpgsql, STABLE, SECURITY DEFINER: returns `(auth.jwt() ->> 'user_role')::text = 'admin'`
    - Create helper function `public.is_authenticated()` returns boolean: returns `auth.uid() IS NOT NULL`
    - These will be used by RLS policies on all tables. Actual table policies created per-table as tables are created in later phases.

    **005_create_audit_triggers.sql:**
    - Create `app_audit_log` table: id (bigint identity PK), user_id (uuid references auth.users), user_email (text), event_type (text NOT NULL), resource_type (text), resource_id (text), action (text NOT NULL), old_data (jsonb), new_data (jsonb), metadata (jsonb), ip_address (text), user_agent (text), created_at (timestamptz default now())
    - Enable RLS on app_audit_log
    - Policy: "All authenticated users can view audit logs" - for SELECT to authenticated, using (true) -- Members get read-only per requirement
    - Policy: "System can insert audit logs" - for INSERT to authenticated, with check (true)
    - Create trigger function `log_role_change()` that inserts into app_audit_log on role changes
    - Create trigger `user_roles_audit_trigger` on user_roles table AFTER INSERT OR UPDATE OR DELETE

    **006_seed_initial_users.sql:**
    - Add commented-out template for seeding initial team members with roles
    - Template: INSERT INTO public.user_roles (user_id, role) VALUES ('uuid-from-auth-users', 'admin');
    - Include comments for the 5 initial users (3 admins, 2 members) with placeholder UUIDs
    - Note: actual UUIDs must be filled in after users sign in for the first time via Google OAuth

    Use exact SQL patterns from 02-RESEARCH.md. Do NOT deviate from the researched patterns.
  </action>
  <verify>
    - All 6 files exist in lib/database/migrations/
    - Each file contains valid SQL (no TypeScript, no markdown)
    - 001 creates app_role enum and user_roles table
    - 002 creates custom_access_token_hook with proper grants
    - 003 enables supa_audit extension
    - 004 creates is_admin() and is_authenticated() helper functions
    - 005 creates app_audit_log table with RLS and trigger
    - 006 has seed template with comments
    - `npx tsc --noEmit` passes (no TS errors from new types)
  </verify>
  <done>All 6 SQL migration files exist with correct schema. Files are ready to copy-paste into Supabase SQL Editor.</done>
</task>

<task type="auto">
  <name>Task 2: Create TypeScript auth types</name>
  <files>
    types/auth.ts
  </files>
  <action>
    Create types/auth.ts with TypeScript type definitions for the auth system:

    - `AppRole` type: 'admin' | 'member'
    - `UserProfile` interface: { id: string; email: string; role: AppRole; fullName?: string; avatarUrl?: string; createdAt: string; }
    - `AuditLogEntry` interface: { id: number; userId: string | null; userEmail: string | null; eventType: string; resourceType: string | null; resourceId: string | null; action: string; oldData: Record<string, unknown> | null; newData: Record<string, unknown> | null; metadata: Record<string, unknown> | null; ipAddress: string | null; userAgent: string | null; createdAt: string; }
    - `AuthEvent` type: 'login' | 'logout' | 'failed_login' | 'role_change' | 'user_added' | 'user_removed' | 'settings_change'
    - `JWTPayload` interface (for decoding access tokens): { sub: string; email: string; user_role?: AppRole; exp: number; iat: number; }
    - Export all types

    Keep types aligned exactly with the SQL schema in the migration files.
  </action>
  <verify>
    - types/auth.ts exists
    - Contains AppRole, UserProfile, AuditLogEntry, AuthEvent, JWTPayload
    - `npx tsc --noEmit` passes
  </verify>
  <done>TypeScript auth types defined and exported, aligned with database schema.</done>
</task>

</tasks>

<verification>
- All SQL migration files parse as valid SQL (no syntax errors)
- TypeScript types compile without errors
- Migration files follow sequential numbering (001-006)
- Auth Hook function has correct GRANT/REVOKE permissions
- RLS policies use correct Supabase auth functions (auth.uid(), auth.jwt())
- app_audit_log table allows SELECT for all authenticated users (member read-only requirement)
</verification>

<success_criteria>
- 6 SQL migration files ready for Supabase SQL Editor execution
- TypeScript types compile and match database schema
- Auth Hook follows Supabase Auth Hooks pattern exactly
- supa_audit extension enabled
- Audit logging infrastructure covers: data changes (supa_audit), auth events (built-in), role changes (custom trigger)
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-security/02-01-SUMMARY.md`
</output>
