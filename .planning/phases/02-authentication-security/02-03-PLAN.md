---
phase: 02-authentication-security
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - components/auth/auth-provider.tsx
  - components/auth/session-expiry-modal.tsx
  - components/auth/role-guard.tsx
  - lib/hooks/use-auth.ts
  - lib/hooks/use-role.ts
  - lib/supabase/auth-helpers.ts
  - app/(dashboard)/layout.tsx
autonomous: true

must_haves:
  truths:
    - "Auth state (user, session, loading) is available to all client components via context"
    - "User role (admin/member) is extracted from JWT and accessible via useRole hook"
    - "Session expiry shows modal overlay instead of hard redirect"
    - "RoleGuard component hides UI elements based on user role"
    - "Server-side role checking is available via auth-helpers"
  artifacts:
    - path: "components/auth/auth-provider.tsx"
      provides: "Auth context provider wrapping dashboard"
      min_lines: 40
    - path: "components/auth/session-expiry-modal.tsx"
      provides: "Modal overlay on session expiration"
      min_lines: 30
    - path: "components/auth/role-guard.tsx"
      provides: "Client-side role-based UI gating"
      min_lines: 20
    - path: "lib/hooks/use-auth.ts"
      provides: "Hook for accessing auth context"
      min_lines: 10
    - path: "lib/hooks/use-role.ts"
      provides: "Hook for accessing user role from JWT"
      min_lines: 20
    - path: "lib/supabase/auth-helpers.ts"
      provides: "Server-side role checking utilities"
      min_lines: 20
  key_links:
    - from: "components/auth/auth-provider.tsx"
      to: "supabase.auth.onAuthStateChange"
      via: "Auth state listener for session changes"
      pattern: "onAuthStateChange"
    - from: "lib/hooks/use-role.ts"
      to: "jwt-decode"
      via: "Decode access token for role claim"
      pattern: "jwtDecode.*user_role"
    - from: "components/auth/session-expiry-modal.tsx"
      to: "supabase.auth.onAuthStateChange"
      via: "Detects SIGNED_OUT event"
      pattern: "SIGNED_OUT"
    - from: "app/(dashboard)/layout.tsx"
      to: "components/auth/auth-provider.tsx"
      via: "Wraps dashboard children"
      pattern: "AuthProvider"
---

<objective>
Build client-side auth infrastructure: AuthProvider context for sharing auth state, useAuth and useRole hooks, session expiry modal (preserves current page, shows re-auth prompt), RoleGuard component for conditional UI rendering, and server-side auth helpers.

Purpose: All subsequent features need to check auth state and user roles. Session expiry UX must preserve user context (AUTH-03, AUTH-04). This is the client-side bridge between Supabase auth and the React component tree.
Output: Auth context system, role hooks, session expiry modal, role guard component, server-side helpers.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-authentication-security/02-RESEARCH.md
@.planning/phases/02-authentication-security/02-CONTEXT.md
@.planning/phases/02-authentication-security/02-01-SUMMARY.md
@.planning/phases/02-authentication-security/02-02-SUMMARY.md
@types/auth.ts
@lib/supabase/client.ts
@lib/supabase/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AuthProvider, useAuth hook, useRole hook, and session expiry modal</name>
  <files>
    components/auth/auth-provider.tsx
    lib/hooks/use-auth.ts
    lib/hooks/use-role.ts
    components/auth/session-expiry-modal.tsx
  </files>
  <action>
    First, install jwt-decode: `npm install jwt-decode`

    **Create AuthProvider** (components/auth/auth-provider.tsx):
    - 'use client'
    - Create AuthContext with React.createContext
    - Context value: { user: User | null; session: Session | null; loading: boolean; signOut: () => Promise<void> }
    - Provider component wraps children, manages auth state via onAuthStateChange listener
    - On mount: get initial session via getSession() (OK for client-side initial load, middleware already validated)
    - Subscribe to onAuthStateChange to update state reactively
    - signOut function: calls supabase.auth.signOut(), no manual redirect needed (middleware handles it)
    - Clean up subscription on unmount
    - Export AuthProvider and AuthContext

    **Create useAuth hook** (lib/hooks/use-auth.ts):
    - Import AuthContext
    - Simple hook that calls useContext(AuthContext) and throws if used outside provider
    - Export useAuth

    **Create useRole hook** (lib/hooks/use-role.ts):
    - 'use client'
    - Import jwtDecode from 'jwt-decode'
    - Import AppRole, JWTPayload from '@/types/auth'
    - Import createClient from '@/lib/supabase/client'
    - Hook state: { role: AppRole | null; loading: boolean; isAdmin: boolean }
    - On mount: get session, decode access_token JWT, extract user_role claim
    - Subscribe to onAuthStateChange to update role when token refreshes
    - Default to 'member' if no role claim found
    - Clean up subscription on unmount
    - Export useRole

    **Create SessionExpiryModal** (components/auth/session-expiry-modal.tsx):
    - 'use client'
    - Import Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription from shadcn/ui
    - Import Button from shadcn/ui
    - Uses createClient to listen for auth state changes
    - Track wasAuthenticated state (starts false, set true on first SIGNED_IN or INITIAL_SESSION with valid session)
    - Show modal ONLY when: wasAuthenticated is true AND event is SIGNED_OUT (prevents flash on initial load)
    - Do NOT show on TOKEN_REFRESHED events (Pitfall 7 from research)
    - Modal text: "Session Expired" / "Your session has expired. Please sign in again to continue where you left off."
    - Button: "Sign In to Continue" - stores current pathname in sessionStorage('returnPath'), redirects to /login
    - Dialog is NOT dismissible (no close button, onOpenChange is no-op) - user MUST re-authenticate
    - Style consistent with dark Valkyrie aesthetic
  </action>
  <verify>
    - `npm list jwt-decode` shows jwt-decode installed
    - components/auth/auth-provider.tsx exists, exports AuthProvider
    - lib/hooks/use-auth.ts exists, exports useAuth
    - lib/hooks/use-role.ts exists, exports useRole with isAdmin property
    - components/auth/session-expiry-modal.tsx exists, uses onAuthStateChange with wasAuthenticated guard
    - Session expiry modal only triggers on SIGNED_OUT when user was previously authenticated
    - `npx tsc --noEmit` passes
  </verify>
  <done>AuthProvider manages auth state. useAuth/useRole hooks provide access to user and role. Session expiry modal handles re-auth UX without losing user context.</done>
</task>

<task type="auto">
  <name>Task 2: Create RoleGuard, server-side auth helpers, and integrate into dashboard</name>
  <files>
    components/auth/role-guard.tsx
    lib/supabase/auth-helpers.ts
    app/(dashboard)/layout.tsx
  </files>
  <action>
    **Create RoleGuard** (components/auth/role-guard.tsx):
    - 'use client'
    - Props: { children: ReactNode; allowedRoles: AppRole[]; fallback?: ReactNode }
    - Uses useRole hook to get current role
    - If loading: return null or skeleton
    - If role not in allowedRoles: return fallback (default: null, hide content silently)
    - Otherwise: render children
    - Export RoleGuard

    **Create server-side auth helpers** (lib/supabase/auth-helpers.ts):
    - Import createClient from '@/lib/supabase/server'
    - Import { jwtDecode } from 'jwt-decode'
    - Import { AppRole, JWTPayload } from '@/types/auth'

    - `getCurrentUser()`: async function that creates server client, calls getUser(), returns user or null
    - `getCurrentRole()`: async function that creates server client, calls getSession(), decodes JWT for user_role, returns AppRole or null. Note: we use getSession() here because getUser() already validated in middleware - this is just for reading the JWT claim.
    - `requireAuth()`: async function that gets user, if no user calls redirect('/login'). Returns user.
    - `requireAdmin()`: async function that gets user + role, if not admin calls redirect('/dashboard'). Returns user.
    - `logAuditEvent(params)`: async function that inserts into app_audit_log table using server client. Params: { eventType: string; resourceType?: string; resourceId?: string; action: string; oldData?: Record<string, unknown>; newData?: Record<string, unknown>; metadata?: Record<string, unknown> }. Automatically fills user_id and user_email from current session.

    **Update dashboard layout** (app/(dashboard)/layout.tsx):
    - Import AuthProvider and SessionExpiryModal
    - Wrap children with AuthProvider
    - Add SessionExpiryModal inside AuthProvider (needs to be inside provider to access auth state, but actually it manages its own state via Supabase listener - place it as sibling)
    - Keep existing server-side auth check (getUser + redirect)
    - Keep sign-out button from 02-02
    - Layout structure: AuthProvider wraps all children + SessionExpiryModal
  </action>
  <verify>
    - components/auth/role-guard.tsx exists, uses useRole hook, conditionally renders children
    - lib/supabase/auth-helpers.ts exists, exports getCurrentUser, getCurrentRole, requireAuth, requireAdmin, logAuditEvent
    - app/(dashboard)/layout.tsx wraps children with AuthProvider and includes SessionExpiryModal
    - RoleGuard hides content when role not in allowedRoles
    - `npx tsc --noEmit` passes
    - `npm run build` succeeds
  </verify>
  <done>RoleGuard enables per-component role gating. Server helpers provide auth checks for Server Components and API routes. Dashboard layout integrates auth provider and session expiry modal.</done>
</task>

</tasks>

<verification>
- AuthProvider provides user/session/loading/signOut to all child components
- useAuth hook throws meaningful error if used outside AuthProvider
- useRole hook correctly decodes JWT custom claims for role
- Session expiry modal appears only when session genuinely expires (not on normal nav)
- RoleGuard conditionally renders based on user role
- Server-side helpers work in Server Components (async, use server client)
- logAuditEvent correctly inserts into app_audit_log
- All TypeScript compiles, Next.js build succeeds
</verification>

<success_criteria>
- AUTH-03 (session persistence): Session expiry modal preserves current page, allows re-auth
- AUTH-04 (RBAC): Role extracted from JWT, RoleGuard gates UI, server helpers gate routes
- Sliding expiration: Middleware refreshes tokens automatically, session extends while active
- Multi-tab: onAuthStateChange syncs across tabs via BroadcastChannel (built into Supabase)
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-security/02-03-SUMMARY.md`
</output>
