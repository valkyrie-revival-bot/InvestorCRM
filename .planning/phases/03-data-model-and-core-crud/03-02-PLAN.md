---
phase: 03-data-model-and-core-crud
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - lib/validations/investor-schema.ts
  - lib/validations/contact-schema.ts
  - app/actions/investors.ts
  - app/actions/contacts.ts
autonomous: true

must_haves:
  truths:
    - "Server action can create an investor with required fields and return the new record"
    - "Server action can update a single field on an investor record"
    - "Server action can soft-delete an investor by setting deleted_at"
    - "Server action can restore a soft-deleted investor by clearing deleted_at"
    - "Server action can fetch an investor with its contacts"
    - "Every investor update logs an activity record"
  artifacts:
    - path: "lib/validations/investor-schema.ts"
      provides: "Zod schemas for investor create and update validation"
      exports: ["investorCreateSchema", "investorUpdateSchema", "investorFieldSchema"]
    - path: "app/actions/investors.ts"
      provides: "Server actions for investor CRUD operations"
      exports: ["createInvestor", "getInvestor", "getInvestors", "updateInvestorField", "softDeleteInvestor", "restoreInvestor"]
    - path: "app/actions/contacts.ts"
      provides: "Server actions for contact CRUD"
      exports: ["createContact", "updateContact", "deleteContact"]
  key_links:
    - from: "app/actions/investors.ts"
      to: "lib/supabase/server.ts"
      via: "createClient() for authenticated Supabase operations"
      pattern: "createClient"
    - from: "app/actions/investors.ts"
      to: "types/investors.ts"
      via: "Type imports for return values and parameters"
      pattern: "import.*from.*types/investors"
    - from: "lib/validations/investor-schema.ts"
      to: "types/investors.ts"
      via: "Zod schema infers same shape as TypeScript types"
      pattern: "InvestorStage|AllocatorType"
---

<objective>
Create Zod validation schemas and Next.js Server Actions for investor and contact CRUD operations.

Purpose: Server actions are the API layer between the UI and Supabase. They handle validation, auth checks, database operations, and activity logging. All form submissions and inline edits will call these actions.
Output: Validation schemas and server actions for full CRUD lifecycle (create, read, update, soft delete, restore).
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-data-model-and-core-crud/03-CONTEXT.md
@.planning/phases/03-data-model-and-core-crud/03-RESEARCH.md
@.planning/phases/03-data-model-and-core-crud/03-01-SUMMARY.md
@types/investors.ts
@lib/supabase/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zod validation schemas for investors and contacts</name>
  <files>
    lib/validations/investor-schema.ts
    lib/validations/contact-schema.ts
  </files>
  <action>
Install required dependencies first:
```bash
npm install react-hook-form zod @hookform/resolvers
```

**lib/validations/investor-schema.ts:**

Create three Zod schemas:

1. `investorCreateSchema` — For the quick create modal (required fields only):
   - `firm_name`: z.string().min(1, "Firm name is required").max(200)
   - `stage`: z.string().min(1, "Stage is required") — validate against INVESTOR_STAGES array
   - `relationship_owner`: z.string().min(1, "Relationship owner is required").max(100)

2. `investorUpdateSchema` — For inline field updates (all fields optional):
   - All 20 data fields as optional, with appropriate validation:
   - `firm_name`: z.string().min(1).max(200).optional()
   - `stage`: z.string() validated against stages array .optional()
   - `relationship_owner`: z.string().min(1).max(100).optional()
   - `partner_source`: z.string().max(200).optional().nullable()
   - `est_value`: z.number().nonnegative().optional().nullable() (nonnegative, not positive — could be 0)
   - `entry_date`: z.string().optional().nullable() (ISO date string)
   - `last_action_date`: z.string().optional().nullable()
   - `stalled`: z.boolean().optional()
   - `allocator_type`: z.string().optional().nullable()
   - `internal_conviction`: z.string().optional().nullable()
   - `internal_priority`: z.string().optional().nullable()
   - `investment_committee_timing`: z.string().optional().nullable()
   - `next_action`: z.string().optional().nullable()
   - `next_action_date`: z.string().optional().nullable()
   - `current_strategy_notes`: z.string().optional().nullable()
   - `current_strategy_date`: z.string().optional().nullable()
   - `last_strategy_notes`: z.string().optional().nullable()
   - `last_strategy_date`: z.string().optional().nullable()
   - `key_objection_risk`: z.string().optional().nullable()

3. `investorFieldSchema` — For single field validation (used by inline edit):
   - A function `validateInvestorField(field: string, value: unknown)` that picks the right field from investorUpdateSchema and validates just that field. Return `{ success: true, data: value }` or `{ success: false, error: string }`.

Export `INVESTOR_STAGES` as a const array with all stage values from types/investors.ts InvestorStage type.
Export `ALLOCATOR_TYPES` as a const array with all allocator type values.

**lib/validations/contact-schema.ts:**

Create `contactSchema`:
- `name`: z.string().min(1, "Contact name is required").max(200)
- `email`: z.string().email("Invalid email").optional().nullable().or(z.literal(''))
- `phone`: z.string().max(50).optional().nullable()
- `title`: z.string().max(200).optional().nullable()
- `notes`: z.string().optional().nullable()
- `is_primary`: z.boolean().optional()
  </action>
  <verify>
Read both schema files. Verify: (1) investorCreateSchema has exactly 3 required fields, (2) investorUpdateSchema has all 20 data fields as optional, (3) INVESTOR_STAGES matches InvestorStage type values, (4) validateInvestorField function exists and handles unknown fields gracefully
  </verify>
  <done>Zod schemas compile without errors and validate all investor/contact data with appropriate constraints</done>
</task>

<task type="auto">
  <name>Task 2: Create server actions for investor and contact CRUD</name>
  <files>
    app/actions/investors.ts
    app/actions/contacts.ts
  </files>
  <action>
**app/actions/investors.ts** — Mark with 'use server' directive at top.

Import createClient from '@/lib/supabase/server', types from '@/types/investors', schemas from '@/lib/validations/investor-schema'.

Implement these server actions:

1. `createInvestor(formData: { firm_name: string; stage: string; relationship_owner: string })`:
   - Validate with investorCreateSchema
   - Get current user via supabase.auth.getUser()
   - Insert into investors table with created_by = user.id, entry_date = today
   - Log activity: type='note', description='Investor record created'
   - revalidatePath('/investors')
   - Return `{ data: investor }` or `{ error: string }`

2. `getInvestor(id: string)`:
   - Fetch investor by id
   - Fetch associated contacts where deleted_at is null, ordered by is_primary DESC
   - Return `InvestorWithContacts` or `{ error: string }`

3. `getInvestors()`:
   - Fetch all non-deleted investors ordered by updated_at DESC
   - Include primary contact name via a join or separate query
   - Return `{ data: Investor[] }` or `{ error: string }`

4. `updateInvestorField(investorId: string, field: string, value: unknown)`:
   - Validate field+value using validateInvestorField
   - Get old value for activity log
   - Update single field + set updated_at
   - Log activity: type='field_update', description=`Updated ${field}`, metadata={field, old_value, new_value}
   - Do NOT call revalidatePath here (inline edit should not trigger full page reload)
   - Return `{ data: updatedInvestor }` or `{ error: string }`

   **CRITICAL for race condition prevention (RESEARCH.md Pitfall 5):** Update ONLY the single field being changed, not the entire record. Use `{ [field]: value, updated_at: new Date().toISOString() }` as the update payload.

5. `softDeleteInvestor(investorId: string)`:
   - Set deleted_at = now() on the investor
   - Log activity: type='note', description='Investor soft-deleted'
   - revalidatePath('/investors')
   - Return `{ success: true }` or `{ error: string }`

6. `restoreInvestor(investorId: string)`:
   - IMPORTANT: Use the admin client (createAdminClient) for this operation because RLS SELECT policy filters out deleted records, and UPDATE requires SELECT first. The regular client can't "see" the deleted record to update it.
   - Set deleted_at = null on the investor
   - Log activity: type='note', description='Investor restored'
   - revalidatePath('/investors')
   - Return `{ success: true }` or `{ error: string }`

**app/actions/contacts.ts** — Mark with 'use server' directive.

1. `createContact(investorId: string, data: { name: string; email?: string; phone?: string; title?: string; notes?: string; is_primary?: boolean })`:
   - Validate with contactSchema
   - If is_primary is true, set all other contacts for this investor to is_primary = false first
   - Insert contact
   - Log activity on investor: type='note', description=`Added contact: ${data.name}`
   - Return `{ data: contact }` or `{ error: string }`

2. `updateContact(contactId: string, field: string, value: unknown)`:
   - Update single field on contact
   - Return `{ data: contact }` or `{ error: string }`

3. `deleteContact(contactId: string)`:
   - Soft delete (set deleted_at)
   - Return `{ success: true }` or `{ error: string }`

All actions must check for authenticated user first. Return `{ error: 'Unauthorized' }` if no user.
  </action>
  <verify>
Read both action files. Verify: (1) All functions marked as server actions ('use server'), (2) createInvestor validates with Zod before insert, (3) updateInvestorField updates single field only (not full record), (4) softDeleteInvestor sets deleted_at timestamp, (5) restoreInvestor uses admin client, (6) Activity logging occurs for create/update/delete operations. Run `npx tsc --noEmit` to check for type errors.
  </verify>
  <done>All 9 server actions (6 investor + 3 contact) compile without type errors, validate inputs, check auth, log activities, and handle errors with consistent return types</done>
</task>

</tasks>

<verification>
- `npm install` completes without errors (react-hook-form, zod, @hookform/resolvers installed)
- `npx tsc --noEmit` passes with no type errors
- Server actions use 'use server' directive
- Zod schemas validate all required/optional field constraints
- updateInvestorField updates single field only (no full record overwrite)
- restoreInvestor uses admin client to bypass RLS SELECT filter
- Activity logging integrated into create, update, and delete operations
</verification>

<success_criteria>
- 4 files created with correct exports
- All server actions handle auth check, validation, database operation, activity logging, and error handling
- Single-field update pattern prevents race conditions
- Admin client used for restore operation (bypasses deleted_at filter)
</success_criteria>

<output>
After completion, create `.planning/phases/03-data-model-and-core-crud/03-02-SUMMARY.md`
</output>
