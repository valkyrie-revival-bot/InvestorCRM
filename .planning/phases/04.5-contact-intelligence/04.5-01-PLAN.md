---
phase: 04.5-contact-intelligence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/database/migrations/016-linkedin-contacts.sql
  - lib/database/migrations/017-investor-relationships.sql
  - types/linkedin.ts
  - lib/validations/linkedin-schema.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "linkedin_contacts table exists in Supabase with proper columns, RLS, and indexes"
    - "investor_relationships table exists in Supabase with proper columns, RLS, and indexes"
    - "pg_trgm extension is enabled for trigram similarity search"
    - "TypeScript types for LinkedInContact and InvestorRelationship are defined"
    - "PapaParse and Fuse.js are installed as dependencies"
    - "Zod schema validates LinkedIn CSV row format with optional email and date transform"
  artifacts:
    - path: "lib/database/migrations/016-linkedin-contacts.sql"
      provides: "linkedin_contacts table DDL with RLS policies and indexes"
      contains: "CREATE TABLE linkedin_contacts"
    - path: "lib/database/migrations/017-investor-relationships.sql"
      provides: "investor_relationships table DDL with RLS policies and indexes"
      contains: "CREATE TABLE investor_relationships"
    - path: "types/linkedin.ts"
      provides: "TypeScript types for LinkedIn domain"
      exports: ["LinkedInContact", "InvestorRelationship", "RelationshipType", "IntroPath"]
    - path: "lib/validations/linkedin-schema.ts"
      provides: "Zod validation schema for LinkedIn CSV rows"
      exports: ["linkedInContactSchema", "LinkedInContactInput"]
  key_links:
    - from: "types/linkedin.ts"
      to: "lib/validations/linkedin-schema.ts"
      via: "shared type definitions"
      pattern: "RelationshipType"
    - from: "lib/database/migrations/017-investor-relationships.sql"
      to: "lib/database/migrations/016-linkedin-contacts.sql"
      via: "foreign key"
      pattern: "REFERENCES linkedin_contacts"
---

<objective>
Create the database foundation and TypeScript type system for LinkedIn contact intelligence.

Purpose: All subsequent plans (CSV import, fuzzy matching, UI) depend on these tables, types, and dependencies existing first.
Output: Two new database tables (linkedin_contacts, investor_relationships), TypeScript types, Zod validation schema, and npm dependencies installed.
</objective>

<execution_context>
@/Users/RAZER/.claude/get-shit-done/workflows/execute-plan.md
@/Users/RAZER/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04.5-contact-intelligence/04.5-RESEARCH.md

Existing patterns to follow:
@types/investors.ts — TypeScript type conventions (interface naming, Omit patterns for Insert/Update)
@lib/validations/investor-schema.ts — Zod schema conventions (z.object, safeParse, field helpers)
@lib/supabase/server.ts — Supabase client pattern (createClient, createAdminClient)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database schema — linkedin_contacts and investor_relationships tables</name>
  <files>
    lib/database/migrations/016-linkedin-contacts.sql
    lib/database/migrations/017-investor-relationships.sql
  </files>
  <action>
    Create two SQL migration files. Run them via Supabase SQL Editor or migration script.

    **016-linkedin-contacts.sql:**
    - Enable pg_trgm extension: `CREATE EXTENSION IF NOT EXISTS pg_trgm;`
    - Create `linkedin_contacts` table with columns:
      - `id` UUID PRIMARY KEY DEFAULT gen_random_uuid()
      - `first_name` TEXT NOT NULL
      - `last_name` TEXT NOT NULL
      - `full_name` TEXT GENERATED ALWAYS AS (first_name || ' ' || last_name) STORED
      - `linkedin_url` TEXT
      - `email` TEXT (nullable — most LinkedIn contacts don't share email)
      - `company` TEXT (nullable)
      - `position` TEXT (nullable)
      - `connected_on` DATE (nullable)
      - `team_member_name` TEXT NOT NULL (e.g., "Todd", "Jeff", "Jackson", "Morino")
      - `normalized_company` TEXT (nullable — populated by trigger or app code, lowercased with legal suffixes removed)
      - `created_at` TIMESTAMPTZ NOT NULL DEFAULT now()
      - `updated_at` TIMESTAMPTZ NOT NULL DEFAULT now()
    - Add unique constraint on (linkedin_url, team_member_name) to prevent duplicate imports per team member
    - Add GIN trigram index on `normalized_company` column: `CREATE INDEX linkedin_contacts_normalized_company_trgm_idx ON linkedin_contacts USING gin (normalized_company gin_trgm_ops);`
    - Add btree index on `team_member_name`
    - Add btree index on `email` for deduplication lookups
    - RLS policies: Enable RLS, allow SELECT/INSERT/UPDATE/DELETE for authenticated users (is_authenticated())
    - updated_at trigger: Create trigger to auto-update updated_at on row change (reuse pattern from investors table if exists, or create `set_updated_at()` function)

    **017-investor-relationships.sql:**
    - Create `investor_relationships` table with columns:
      - `id` UUID PRIMARY KEY DEFAULT gen_random_uuid()
      - `investor_id` UUID NOT NULL REFERENCES investors(id) ON DELETE CASCADE
      - `linkedin_contact_id` UUID NOT NULL REFERENCES linkedin_contacts(id) ON DELETE CASCADE
      - `relationship_type` TEXT NOT NULL CHECK (relationship_type IN ('works_at', 'former_colleague', 'knows_decision_maker', 'industry_overlap', 'geographic_proximity'))
      - `path_strength` NUMERIC(3,2) NOT NULL DEFAULT 0.00 CHECK (path_strength >= 0 AND path_strength <= 1)
      - `path_description` TEXT (human-readable explanation of the intro path)
      - `detected_via` TEXT NOT NULL DEFAULT 'company_match' CHECK (detected_via IN ('company_match', 'manual', 'email_match', 'name_match'))
      - `created_at` TIMESTAMPTZ NOT NULL DEFAULT now()
      - `updated_at` TIMESTAMPTZ NOT NULL DEFAULT now()
    - Add unique constraint on (investor_id, linkedin_contact_id, relationship_type) to prevent duplicate relationships
    - Add composite index on (investor_id, path_strength DESC) for fast lookups sorted by strength
    - Add index on linkedin_contact_id for reverse lookups
    - RLS policies: Enable RLS, allow SELECT/INSERT/UPDATE/DELETE for authenticated users
    - updated_at trigger

    **IMPORTANT:** Do NOT add a normalized_firm_name generated column to the investors table yet. The matching will normalize on-the-fly in the application layer for now (investors table has <100 records). Can add computed column later for scale.
  </action>
  <verify>
    Run both migration SQL files against Supabase. Verify:
    - `SELECT * FROM information_schema.tables WHERE table_name IN ('linkedin_contacts', 'investor_relationships');` returns 2 rows
    - `SELECT * FROM pg_extension WHERE extname = 'pg_trgm';` returns 1 row
    - `SELECT indexname FROM pg_indexes WHERE tablename = 'linkedin_contacts' AND indexname LIKE '%trgm%';` returns 1 row
    - Test RLS: insert a test row, select it, delete it
  </verify>
  <done>
    Both tables exist in Supabase with all columns, constraints, indexes (including GIN trigram), RLS policies, and triggers. pg_trgm extension is enabled.
  </done>
</task>

<task type="auto">
  <name>Task 2: TypeScript types, Zod schema, and npm dependencies</name>
  <files>
    types/linkedin.ts
    lib/validations/linkedin-schema.ts
    package.json
  </files>
  <action>
    **Install dependencies:**
    ```bash
    npm install papaparse fuse.js
    npm install --save-dev @types/papaparse
    ```

    **types/linkedin.ts:**
    Define types mirroring the database schema and application needs. Follow conventions from types/investors.ts:

    ```typescript
    // Relationship type enum
    export type RelationshipType =
      | 'works_at'
      | 'former_colleague'
      | 'knows_decision_maker'
      | 'industry_overlap'
      | 'geographic_proximity';

    // Database entity: linkedin_contacts table
    export interface LinkedInContact {
      id: string;
      first_name: string;
      last_name: string;
      full_name: string; // Generated column
      linkedin_url: string | null;
      email: string | null;
      company: string | null;
      position: string | null;
      connected_on: string | null; // ISO date string
      team_member_name: string;
      normalized_company: string | null;
      created_at: string;
      updated_at: string;
    }

    // Database entity: investor_relationships table
    export interface InvestorRelationship {
      id: string;
      investor_id: string;
      linkedin_contact_id: string;
      relationship_type: RelationshipType;
      path_strength: number; // 0.00 to 1.00
      path_description: string | null;
      detected_via: 'company_match' | 'manual' | 'email_match' | 'name_match';
      created_at: string;
      updated_at: string;
    }

    // Composite: relationship with LinkedIn contact populated
    export interface InvestorRelationshipWithContact extends InvestorRelationship {
      linkedin_contact: LinkedInContact;
    }

    // Warm introduction path (computed, not stored)
    export interface IntroPath {
      linkedin_contact_id: string;
      contact_name: string;
      contact_company: string | null;
      contact_position: string | null;
      team_member_name: string;
      relationship_type: RelationshipType;
      path_strength: number;
      strength_label: 'strong' | 'medium' | 'weak';
      path_description: string;
      linkedin_url: string | null;
    }

    // Insert types
    export type LinkedInContactInsert = Omit<LinkedInContact, 'id' | 'full_name' | 'created_at' | 'updated_at'>;
    export type InvestorRelationshipInsert = Omit<InvestorRelationship, 'id' | 'created_at' | 'updated_at'>;

    // Import result type
    export interface ImportResult {
      success: boolean;
      imported: number;
      skipped: number;
      errors: Array<{ row: number; message: string }>;
      relationships_detected: number;
    }

    // Team members for CSV import
    export const TEAM_MEMBERS = ['Todd', 'Jeff', 'Jackson', 'Morino'] as const;
    export type TeamMember = typeof TEAM_MEMBERS[number];
    ```

    **lib/validations/linkedin-schema.ts:**
    Create Zod schema for validating parsed CSV rows. Follow conventions from investor-schema.ts:

    ```typescript
    import { z } from 'zod';

    // Schema for a single LinkedIn CSV row after header transformation
    export const linkedInContactRowSchema = z.object({
      first_name: z.string().min(1, 'First name required').max(200),
      last_name: z.string().min(1, 'Last name required').max(200),
      linkedin_url: z.string().url('Invalid LinkedIn URL').optional().or(z.literal('')).transform(v => v || null),
      email: z.string().email('Invalid email').optional().or(z.literal('')).transform(v => v || null),
      company: z.string().optional().or(z.literal('')).transform(v => v || null),
      position: z.string().optional().or(z.literal('')).transform(v => v || null),
      connected_on: z.string().optional().or(z.literal('')).transform(val => {
        if (!val) return null;
        // LinkedIn date format: "10 Feb 2026" or "01 Jan 2024"
        const date = new Date(val);
        return isNaN(date.getTime()) ? null : date.toISOString().split('T')[0];
      }).nullable(),
    });

    export type LinkedInContactRowInput = z.infer<typeof linkedInContactRowSchema>;

    // Validate and transform array of parsed CSV rows
    export function validateLinkedInRows(rows: unknown[]) {
      const validated: Array<{ row: number; data: LinkedInContactRowInput }> = [];
      const errors: Array<{ row: number; field: string; message: string }> = [];

      for (let i = 0; i < rows.length; i++) {
        const result = linkedInContactRowSchema.safeParse(rows[i]);
        if (result.success) {
          validated.push({ row: i + 1, data: result.data });
        } else {
          for (const issue of result.error.issues) {
            errors.push({
              row: i + 1,
              field: issue.path.join('.'),
              message: issue.message,
            });
          }
        }
      }

      return { validated, errors };
    }
    ```
  </action>
  <verify>
    - `npm ls papaparse fuse.js` shows both installed
    - `npx tsc --noEmit` compiles without type errors in the new files
    - The Zod schema can parse a sample LinkedIn row: test mentally or via a quick script
  </verify>
  <done>
    PapaParse and Fuse.js installed. TypeScript types defined for LinkedInContact, InvestorRelationship, IntroPath, and all insert/composite types. Zod validation schema handles LinkedIn CSV format with optional email, date transformation, and empty string to null coercion. All types follow existing project conventions.
  </done>
</task>

</tasks>

<verification>
1. Database: Both tables exist with correct columns, constraints, and indexes
2. pg_trgm: Extension enabled and GIN index created on normalized_company
3. Types: `types/linkedin.ts` exports all required interfaces and type unions
4. Validation: `lib/validations/linkedin-schema.ts` exports schema and validation helper
5. Dependencies: `papaparse`, `fuse.js`, `@types/papaparse` in package.json
6. Build: `npx tsc --noEmit` passes with no errors
</verification>

<success_criteria>
- `linkedin_contacts` and `investor_relationships` tables exist in Supabase with RLS enabled
- pg_trgm extension is active with GIN index on normalized_company
- TypeScript types compile cleanly and are importable from `@/types/linkedin`
- Zod schema correctly validates LinkedIn CSV row format
- PapaParse and Fuse.js are installed and available for import
</success_criteria>

<output>
After completion, create `.planning/phases/04.5-contact-intelligence/04.5-01-SUMMARY.md`
</output>
