-- Run in Supabase SQL Editor - Migration 1 of 6
-- Creates role enum and user_roles table with RLS policies

-- Create role enum (Admin, Member)
create type public.app_role as enum ('admin', 'member');

-- User roles table
create table public.user_roles (
  id        bigint generated by default as identity primary key,
  user_id   uuid references auth.users on delete cascade not null,
  role      app_role not null,
  created_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now(),
  unique (user_id, role)
);

-- Enable RLS
alter table public.user_roles enable row level security;

-- Only admins can manage roles
create policy "Admins can manage user roles"
  on public.user_roles
  for all
  to authenticated
  using (
    exists (
      select 1 from public.user_roles ur
      where ur.user_id = auth.uid() and ur.role = 'admin'
    )
  );

-- All authenticated users can view roles
create policy "Users can view all roles"
  on public.user_roles
  for select
  to authenticated
  using (true);
-- Run in Supabase SQL Editor - Migration 2 of 6
-- Creates Auth Hook function to add user_role claim to JWT tokens
-- IMPORTANT: After running, configure in Supabase Dashboard:
-- Authentication > Hooks > Custom Access Token Hook
-- Schema: public | Function: custom_access_token_hook

-- Auth Hook to add role to JWT
create or replace function public.custom_access_token_hook(event jsonb)
returns jsonb
language plpgsql
stable
as $$
  declare
    claims jsonb;
    user_role public.app_role;
  begin
    -- Fetch user's role (only one role per user in this system)
    select role into user_role
    from public.user_roles
    where user_id = (event->>'user_id')::uuid
    limit 1;

    claims := event->'claims';

    if user_role is not null then
      claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
    else
      -- Default to member if no role assigned
      claims := jsonb_set(claims, '{user_role}', '"member"');
    end if;

    event := jsonb_set(event, '{claims}', claims);
    return event;
  end;
$$;

-- Grant execute to supabase_auth_admin (required for hooks)
grant execute on function public.custom_access_token_hook to supabase_auth_admin;

-- Revoke from authenticated and public (security best practice)
revoke execute on function public.custom_access_token_hook from authenticated, anon, public;
-- Run in Supabase SQL Editor - Migration 3 of 6
-- Enables supa_audit extension for database change tracking

-- Install supa_audit extension
create extension if not exists supa_audit cascade;

-- Enable tracking on user_roles table
select audit.enable_tracking('public.user_roles'::regclass);

-- Note: Additional tables (investors, etc.) will have tracking enabled
-- when they are created in later phases. For now, only user_roles is tracked.

-- To query audit history for user_roles:
-- select * from audit.record_version
-- where table_oid = 'public.user_roles'::regclass::oid
-- order by ts desc;
-- Run in Supabase SQL Editor - Migration 4 of 6
-- Creates helper functions for RLS policies
-- These will be used by all tables requiring role-based access control

-- Helper function to check if user is admin
create or replace function public.is_admin()
returns boolean
language plpgsql
stable
security definer
as $$
begin
  return (auth.jwt() ->> 'user_role')::text = 'admin';
end;
$$;

-- Helper function to check if user is authenticated
create or replace function public.is_authenticated()
returns boolean
language plpgsql
stable
security definer
as $$
begin
  return auth.uid() is not null;
end;
$$;

-- Note: Actual table RLS policies will be created on individual tables
-- as they are created in later phases (investors table in Phase 3, etc.)
-- These helper functions provide consistent role-checking logic across all policies.
-- Run in Supabase SQL Editor - Migration 5 of 6
-- Creates application-level audit log table and triggers for business events

-- Application audit log table
create table if not exists public.app_audit_log (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users,
  user_email text,
  event_type text not null,       -- 'role_change', 'settings_update', 'auth_event', etc.
  resource_type text,              -- 'user', 'investor', 'settings'
  resource_id text,
  action text not null,            -- 'create', 'update', 'delete', 'assign_role', etc.
  old_data jsonb,
  new_data jsonb,
  metadata jsonb,                  -- Additional context
  ip_address text,
  user_agent text,
  created_at timestamp with time zone default now()
);

-- Enable RLS on app_audit_log
alter table public.app_audit_log enable row level security;

-- All authenticated users can view audit logs (members have read-only per requirements)
create policy "All authenticated users can view audit logs"
  on public.app_audit_log
  for select
  to authenticated
  using (true);

-- System can insert audit logs
create policy "System can insert audit logs"
  on public.app_audit_log
  for insert
  to authenticated
  with check (true);

-- Function to log role changes
create or replace function public.log_role_change()
returns trigger
language plpgsql
security definer
as $$
declare
  actor_email text;
begin
  select email into actor_email from auth.users where id = auth.uid();

  if (TG_OP = 'INSERT') then
    insert into public.app_audit_log (
      user_id, user_email, event_type, resource_type,
      resource_id, action, new_data
    ) values (
      auth.uid(), actor_email, 'role_change', 'user',
      NEW.user_id::text, 'assign_role',
      jsonb_build_object('role', NEW.role)
    );
    return NEW;
  elsif (TG_OP = 'UPDATE') then
    insert into public.app_audit_log (
      user_id, user_email, event_type, resource_type,
      resource_id, action, old_data, new_data
    ) values (
      auth.uid(), actor_email, 'role_change', 'user',
      NEW.user_id::text, 'change_role',
      jsonb_build_object('role', OLD.role),
      jsonb_build_object('role', NEW.role)
    );
    return NEW;
  elsif (TG_OP = 'DELETE') then
    insert into public.app_audit_log (
      user_id, user_email, event_type, resource_type,
      resource_id, action, old_data
    ) values (
      auth.uid(), actor_email, 'role_change', 'user',
      OLD.user_id::text, 'remove_role',
      jsonb_build_object('role', OLD.role)
    );
    return OLD;
  end if;
end;
$$;

-- Trigger on user_roles table to log all role changes
create trigger user_roles_audit_trigger
  after insert or update or delete on public.user_roles
  for each row execute function public.log_role_change();
-- Run in Supabase SQL Editor - Migration 6 of 6
-- Template for seeding initial team members with roles
-- IMPORTANT: This file contains placeholders only.
-- Users must first sign in via Google OAuth, then UUIDs can be retrieved
-- from auth.users table and inserted here.

-- Step 1: Have all 5 team members sign in via Google OAuth
-- Step 2: Get their user_id values:
-- select id, email from auth.users order by created_at desc;

-- Step 3: Uncomment and fill in the INSERT statements below:

-- Initial Admins (3 users)
-- insert into public.user_roles (user_id, role) values
--   ('00000000-0000-0000-0000-000000000001', 'admin'),  -- Replace with actual UUID from auth.users
--   ('00000000-0000-0000-0000-000000000002', 'admin'),  -- Replace with actual UUID from auth.users
--   ('00000000-0000-0000-0000-000000000003', 'admin');  -- Replace with actual UUID from auth.users

-- Initial Members (2 users)
-- insert into public.user_roles (user_id, role) values
--   ('00000000-0000-0000-0000-000000000004', 'member'), -- Replace with actual UUID from auth.users
--   ('00000000-0000-0000-0000-000000000005', 'member'); -- Replace with actual UUID from auth.users

-- Verification query (run after inserting):
-- select
--   u.email,
--   ur.role,
--   ur.created_at
-- from public.user_roles ur
-- join auth.users u on u.id = ur.user_id
-- order by ur.created_at;
