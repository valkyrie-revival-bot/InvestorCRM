-- Migration 1: User Roles Table
create type public.app_role as enum ('admin', 'member');

create table public.user_roles (
  id        bigint generated by default as identity primary key,
  user_id   uuid references auth.users on delete cascade not null,
  role      app_role not null,
  created_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now(),
  unique (user_id, role)
);

alter table public.user_roles enable row level security;

create policy "Admins can manage user roles"
  on public.user_roles for all to authenticated
  using (exists (select 1 from public.user_roles ur where ur.user_id = auth.uid() and ur.role = 'admin'));

create policy "Users can view all roles"
  on public.user_roles for select to authenticated using (true);

-- Migration 2: Auth Hook
create or replace function public.custom_access_token_hook(event jsonb)
returns jsonb language plpgsql stable as $$
  declare
    claims jsonb;
    user_role public.app_role;
  begin
    select role into user_role from public.user_roles where user_id = (event->>'user_id')::uuid limit 1;
    claims := event->'claims';
    if user_role is not null then
      claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
    else
      claims := jsonb_set(claims, '{user_role}', '"member"');
    end if;
    event := jsonb_set(event, '{claims}', claims);
    return event;
  end;
$$;

grant execute on function public.custom_access_token_hook to supabase_auth_admin;
revoke execute on function public.custom_access_token_hook from authenticated, anon, public;

-- Migration 3: SKIPPED (supa_audit not available)

-- Migration 4: RLS Helper Functions
create or replace function public.is_admin() returns boolean language plpgsql stable security definer as $$
  begin
    return (auth.jwt() ->> 'user_role')::text = 'admin';
  end;
$$;

create or replace function public.is_authenticated() returns boolean language plpgsql stable security definer as $$
  begin
    return auth.uid() is not null;
  end;
$$;

-- Migration 5: Audit Log Table
create table public.app_audit_log (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users,
  user_email text,
  event_type text not null,
  resource_type text,
  resource_id text,
  action text not null,
  old_data jsonb,
  new_data jsonb,
  metadata jsonb,
  ip_address text,
  user_agent text,
  created_at timestamp with time zone default now()
);

alter table public.app_audit_log enable row level security;

create policy "All authenticated users can view audit logs"
  on public.app_audit_log for select to authenticated using (true);

create policy "System can insert audit logs"
  on public.app_audit_log for insert to authenticated with check (true);

-- Trigger for role changes
create or replace function public.log_role_change()
returns trigger language plpgsql security definer as $$
  begin
    insert into public.app_audit_log (user_id, user_email, event_type, resource_type, resource_id, action, old_data, new_data)
    values (
      auth.uid(),
      (select email from auth.users where id = auth.uid()),
      'role_change',
      'user_role',
      new.user_id::text,
      case when TG_OP = 'INSERT' then 'create' when TG_OP = 'UPDATE' then 'update' else 'delete' end,
      case when TG_OP = 'DELETE' then to_jsonb(old) else null end,
      case when TG_OP = 'DELETE' then null else to_jsonb(new) end
    );
    return new;
  end;
$$;

create trigger user_roles_audit_trigger
  after insert or update or delete on public.user_roles
  for each row execute function public.log_role_change();

-- Migration 6: Seed template (commented out - will be filled manually)
-- Run MAKE_ADMIN.sql after this to assign your admin role
